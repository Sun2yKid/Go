https://github.com/goinaction/code

## Note:
在Go语言中，所有的变量都以值的方式传递，指针变量的值是所指向的内存地址，在函数间传递指针变量，是在传递这个地址值。   P19

Go语言支持闭包，函数可以直接访问到那些没有作为参数传入的变量。

空结构体在创建实例时，不会分配任何内存。    P26

程序里所有的init方法都会在main函数启动前被调用。

使用range迭代切片会创建每个元素的副本，而不是直接返回对该元素的引用.     P72

在函数之间传递变量时，总是以值的方式传递的。

在函数间传递数组是一个很大的操作，可以只传入指向数组的指针，这样只需要复制指针的8字节数据而不是整个数组到栈上（注意共享内存）。    P60

在函数间传递切片就是要在函数间以值的方式传递切片。切片尺寸很小，64位机器上，一个切片需要24字节的内存: 指针，长度和容量分别8字节。    P75

在函数间传递映射并不会制造出该映射的一个副本。    P81

多态是指根据类型的具体实现采取不同行为的能力。如果一个类型实现了某个接口，所有使用这个接口的地方，都可以支持这种类型的值。    P95

规范里描述的方法集
| Values   | Methods receivers  |
|  ----  | ----  |
| T  | (t, T) |
| *T  | (t, T) and (t *T) |

## Best Practise
如果声明函数的时候带有接受者，则意味着生命了一个方法。这个方法会和指定的接受者的类型绑在一起。

无论我们是使用接受者类型的值来调用这个方法，还是使用接收者类型值的指针来调用这个方法，编译器都会正确地引用或者解引用对应的值，作为接受者传递给方法。

因为大部分方法在被调用后都需要维护接收者的值的状态，所以，一个最佳实践是，将方法的接收者声明为指针。  P27

如果在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个append操作创建新的底层数组，与原有的底层数组分离。    P70

任何时候，创建一个变量并初始化为其零值，习惯是使用关键字var。这种用法是为了更明确地标识一个变量被设置为零值。

将工厂函数命名为New是Go语言的一个习惯。